db를 써볼건데, 표처럼 데이터를 보관하는 관계형 db(sql계열), 비관계형 db(몽고, 클라우드 파이어스토어 등)가 있다. 몽고db는 obj처럼 데이터를 저장할 수 있다. sql문법이 필요없기 때문에 몽고db는 진입장벽이 낮다. 분산처리도 잘해준다.

관계형 데이터베이스는 데이터를 엑셀처럼 표에 저장합니다.
데이터 입출력시 SQL이라는 언어를 사용해야하고 미리 스키마 정의(표만들기)도 해야하고 데이터 중복저장을 피하기 위해 정규화해야하고 여러가지 귀찮은 점들을 신경써야합니다.
주로 안정적인 데이터저장과 운영이 필요한 곳에서 쓰면 좋습니다.

비관계형 데이터베이스는 자료를 조금 더 자유로운 형식으로 저장할 수 있고
SQL 언어, 스키마 정의(표 만들기), 정규화 이런게 대부분 필요없습니다.
분산처리를 기본적으로 잘해서 주로 SNS 서비스처럼 많은 데이터 입출력이 필요할 때도 강점을 보입니다. 데이터를 자바스크립트 object자료형과 똑같은 모양으로 저장할 수 있어서 편리합니다.

MongoDB의 데이터 저장 방식
collection을 하나 만들어서 그 안에 document 를 만들어서 데이터를 기록하는 식으로 데이터들을 저장합니다.
비유하자면 collection은 폴더, document는 파일이라고 생각합시다.
Nodejs 강의에선 collection이 폴더, document가 데이터 한 줄이라고 한거같은데 그렇게 생각해도 됩니다.

{ 데이터이름1 : 값1, 데이터이름2 : 값2 ... }
document에 데이터를 기록할 때는 자바스크립트 object 자료형과 똑같이 저장하면 됩니다.

object 자료형은 이렇게 데이터를 저장하는데 이거 그대로 사용하면 됩니다.

### 0903

database에 데이터를 add해보자. 몽고db에 들어가서 데이터를 추가하면 database name은 하나의 프로젝트(사이트 하나당 하나가 일반적이나, 때에 따라 여러개의 db를 생성하기도 함), collection name은 하나의 '폴더'라고 생각하면 된다. collection 폴더 안에 여러개의 document(메모장 파일. 여기에 객체 자료들을 저장함)를 또 하위저장하는 구조가 됨.
insert document를 누르면 키와 값을 입력하는 공간이 있고, 제일 상단에는 기본적으로 부여되는 doc \_id번호가 있다.

// DB를 불러왔으면 페이지는 이제 어떻게 꾸미는가?
모든 개발자들 다 똑같다. 먼저 구현하고 싶은 기능을 '한글'로 풀어써봐라. 그 다음엔 그것에 맞게

1. HTML페이지를 만들어 놓음(뼈대)
2. 그 페이지 방문하면 DB에서 글 꺼내옴
3. 글들을 HTML에 꽂아넣음

// 기본적으로 next에서 라우팅 하는 방법은 다들 아실걸요. 근데 1000개도 넘는 페이지 만들겁니까? 그럴때에는 dynamic route 쓰면 됩니다. 비슷한 페이지는 여러개 만들 필요가 없습니다.

1. 우선 폴더를 [작명] 작명합니다.
2. 그러면 예를들어, detail/~ 뒤에 아무거나 입력해서 접속해도 하위 page.js를 보여줄것임.
3. 근데 진짜 '아무거나'라고 해서 똑같은 내용만 보여주면 안되니까. 범위를 지정해주려면, 여타 다른 블로그의 라우팅 방식처럼, 게시글의 id값(유저가 URL에 입력할 값)을 detail/???에 들어오게 하면 되지요. 방법은 detail/??? 이하에 올 컴포넌트 안에서 props를 출력해보면 params에 대한 정보가 나온다!

### 0908

1. 상세페이지 만드는 것처럼 url과 여러페이지 만들려면 [Dynamic Route] 사용
2. 현재 URL이 뭔지 궁금하면 props/useRouter
3. 페이지 이동, prefetch 등은 useRouter

- usePathname() 쓰면 현재 URL 출력해주고
  useSearchParams() 쓰면 search parameter (query string) 출력해주고
  useParams() 쓰면 [dynamic route]에 입력한내용 (URL 파라미터) 을 출력해줍니다.

### 0910

+글 작성 기능을 넣어보자!
순서대로,

1. 글 작성 페이지 필요하겠쬬?
2. 버튼 누르면 DB에 저장하는 방식? no!! 유저가 글에 공백이나 기타 이상한 것을 담아 보낼 수 있기 때문에 db에 '바로' 저장하는건 위험한 행동이다. 중간에 서버를 하나를 둬서 글 검사하도록 합니다.(이런 방식을 무슨 3-tier architecture 모라모라 한답니다.)
3. 서버라는건 뭐 해달라고하면 요청하면 해주는 프로그램. 서버 프로그램은 어떻게 짜는데요 그럼?
   그 형식은 /URL + method(GET,POST,PUT,DELETE,PATCH 등)로 짜면 된다. method는 정확한 기능들이 나누어져 있습니다.

-next에서 서버 기능을 개발하는건 두가지 방식이 있음.
첫번재는 루트경로에 pages/api/..js 파일을 만드는것,
다른 하나는 app/api/..js 를 만드는건데 후자가 더 최신에 나온것이긴 하다만 강의날을 기준으로 아직 나사빠진 기능이 더 많아서 page/api/~로 진행

-next는 자동 라우팅 기능이 있기 때문에 서버기능을 위해 pages/api와 같이 파일과 폴더를 만들어 놓으면 어떤 사람이 /apit/test로 CRUD와 관련된 요청을하면 '파일안의 코드'를 실행시켜줌!

### 0919

글 수정 페이지를 만들어보자. 근데 기능 정의하는데 어려움을 겪는다구요? 그럼 네이버 블로그 같은 곳을 참고해보십시오. 수정페이지를 들어가보면 큰 특징이 있슴.

1. 글 작성페이지와 'UI'가 같다. (사실 절대 조건은 아니지만 ux를 고려할때 똑같이 설계하는게 맞다)
2. 기존에 작성했던 내용이 채워져있다(아마 DB에 있는 내용)

결론은

1. list에서 글 수정 버튼 하나씩 달아줍시다.
2. 수정페이지를 만듭시다.(글도 db에서 가져오기)
3. 수정페이지에서 글 발행 누르면 db에 있던 내용을 수정하도록 합시다.

### 0926

Nextjs 에선 server / client component 들을 보여줘야할 때 최대한 서버에서 미리 html을 만들어서 보내려고 하기 때문에 server - client로 감싸진 형태로 제작한뒤, DB에서 가져온 데이터를 server 컴포넌트에서 작성한뒤, props로 client로 전송해주는 방식으로 만들자. (seo를 고려할때에)

fetch 코드가 길고 귀찮아서 편리하게 바꿔주는 axios같은 라이브러리 설치해서 쓰는 사람들이 많습니다. 근데 Nextjs 13부터는 fetch가 특별한 기능이 추가되어있기 때문에
server component 함수 안에서 fetch() 쓸 일이 있을 경우 그거 그대로 쓰는게 좋습니다.
지금의 client component 에선 라이브러리 설치하든 뭐하든 편한거 아무거나 대충 써도 됩니다.

### 1004

애니메이션 어떻게 줌?
css에서 애니메 동작 전, 후 스타일만 생각하고 작성하면된다.

-지금까지 서버에 데이터를 보내는 방법으로,
-fetch에서 body에 담는법, -<form>태그에서 <input>에 넣어 보내는법을 알아봤다.

### 1022

**_기능구현 다 했다면 언제나 그 다음에 할 일은 성능향상입니다.2개의 rendering 방법과 캐싱기능에 대해 알아봅시다._**

우선 Next.js로 만든 서버를 어디 배포하려면 터미널 열어서 npm run build를 먼저 해야합니다.
이상한 리액트 문법으로 작성한 코드들을 브라우저 친화적인 html, js, css 파일로 바꿔주는 작업입니다.
그 다음에 npm run start 해두면 실제로 유저 요청을 처리할 수 있는 Next.js 서버가 완성됩니다.(개발 서버 아니고 실제 서버 띄워줌.)
물론 실제 운영할 사이트면 AWS같은 클라우드에 올려서 npm run start 해놓으면 되는데 그건 나중에 해봅시다.

run build를 하고나면 라우팅 된 페이지들을 보여주는데(이름과 사이즈 등을 알려줌), O는 static rendering(default) 해주겠다라는 의미이다.(npm run build 할 때 만든 html페이지 그대로 유저에게 보여줌). λ(람다)는 dynamic rendering 해주겠다는 의미이다. next에서 단순하게 page를 만들면 단순하게 static rendering 해준다.

static rendering 단순한 기능. 미리페이지 완성본 만들어놨기 때문에 전송 빠름.
dynamic rendering 유저가 페이지에 접속할떄마다 html 새로 만들어서 보내줌. npm run build 할때 만든건 버리고 새로 만들어줌.두개 방식의 구분은 자동으로 됨. fetch, useSearchParams(), cookies(), headers() [dynamic route] 페이지에서 사용시 자동으로 dynamic rendering 해줌.

근데 간혹가다가 이상하게 작업된 페이지들이 있음. (예를 들어 DB에서 게시글 가져와하는 list는 static으로 되어있음. 매번 html을 새로 해줘야하는데도..) 그렇기 때문에 npm run build 과정이 중요하다. 단적인 예로 개발 서버 말고 npm run start 한 서버에서 글을 작성해보면 static rendering이 된 html을 가지고 있기 때문에 list에 새로운 글이 반영되지 않는다. 그롷다면 list 페이지를 dynamic rendering으로 만들어보자.

list 페이지에서 export const dynamic = "force-dynamic"; 하면+

force-dynamic' 넣으면 dynamic rendering을 해주고
'force-static' 넣으면 static rendering을 해줍니다.
**_ 작성한 다음엔 꼭\* npm run build 과정을 거쳐주길 바람. _**

하지만 dynamic rendering도 항상 html을 다시 그려야하기 때문에 유저가 많으면 서버나 DB무리가 갈 수도 있기 때문에 그럴때에는 '캐싱' 해줄 수 있따. 데이터를(완성본) 잠깐 몰래 저장해두고, 재사용 하는 것이다. 이런식으로 캐싱하면 서버의 부담이 덜 해질 수 있다..

캐싱기능
예를 들어 GET 요청 결과 같은 것을 잠깐 저장해두고 재사용이 가능하다.

```
export default async function 페이지(){
let result = await fetch('/api/어쩌구', { cache: 'force-cache' })
}
```

fetch() 사용시 cache: 'force-cache' 설정을 넣어두면 캐싱해주고 앞으로 /URL로 요청할 때 마다 계속 캐싱된 결과를 가져와줍니다. 사이트 다시 npm run build 하기 전 까지 캐싱된걸 평생 보여줌

(참고) 실은 { cache: 'force-cache' } 이거 안적어도 디폴트값은 cache: 'force-cache' 로 설정되어있습니다.

이런식으로 저장하면 결과를 몰래 저장해두고 서버 요청이 있을 때마다 그것을 사용한다. 실시간 데이터가 중요하다면 { cache: 'no-store' }를 사용해서 늘 새로운 요청을 보낼 수 있다.

또한 1초 단위 수준으로 데이터 요청이 필요없는 페이지들은 fetch('/URL', { next: { revalidate: 60 } }) 과 같이 사용해서(초단위 기입) 지정된 시간마다 캐싱할 수 있다.

DB의 출력 결과를 캐싱 가능한가? 가능하다.

1. db에서 데이터를 가져오는 코드를 서버 API로 돌려두고 fetch에서 그 서버 API로 요청하면 된다.

2. 두번째 방법은 페이지 단위로 캐싱가능하다. export const revalidate
   = 60; 과 같이 작성하면 된다. 예전 next에서는 ISR이라고 불렸따. (list2 페이지 참고)

\*\*캐싱결과를 확인하기 위해선 반드시 개발서버(npm run dev)가 아니라 실제서버(npm run build/npm run start) 띄워야합니다!

### 1024

게시물을 '로그인 한 사람' 만 볼 수 있게? => 회원기능이 필요

1. 유저 -> id/pw -> DB 에 보내고,
2. 그 이후에 중간에 있는 서버는 DB에 있는 id/pw와 일치하는지 비교 작업을 진행하게 됨. 그리고 유저에게 입장권을 주게됨. (입장권은 유저자료가 써있는 간단한 문자자료, 누구고, 언제 로그인했고.. 등등)
3. 서버에 GET/POST 요청시, 그 입장권을 함께 보여준 뒤 이상이 없으면 게시물 데이터를 보내주는게 회원기능의 방식이다.

브라우저 쿠키저장소(Cookies)에 저장된 문자열들이 바로 입장권들을 몰래 저장시킨다.

**입장권을 만드는 방법은 여기서 택1 하십시오.**

1. session 방식: session id만 달랑 적혀있다. 유저가 로그인을 완료하면 DB에 아이디/로그인날짜/유효기간/ session id를 기록하는데, 유저한테 입장권을 발급해줄때, 세션id만 달랑보내줌. 그래서 확인할때에도 DB에서도 간단하게 session id만 대조해본다.
   장점: 유저의 get/post 요청마다 로그인상태 체크가능
   단점: DB짱이 힘들어함 -> redis같은 session 보관에 특화된 DB써도 좋습니다.

2. token 방식: 거의다 JWT이다. 일단 유저가 로그인을 성공하면 유저한테 입장권을 주는데, 입장권에 아이디,로그인날짜,유효기간 등을 '암호화'해서 보낸다. 유저가 다시 get/post등을 요청하면 입장권을 까보고 이거 보고 별 이상없으면 통과시켜줌. 간단한 토큰 방식.. 보안상 허술하거나 이상해보이겠지만, 암호화되기 때문에 짧은 문자열이 변화해도 위조가 드러나기 때문에 괜찮다.
   장점: DB조회를 안하기 떄문에, 유저 많거나 마이크로 서비스 운영중이면 편하다.
   단점: 나쁜놈이 훔쳐가면 그 사람이 로그인하는걸 막을 수 없다. 다른 컴퓨터 로그아웃 거의 불가능..

OAuth의 개념
:유저의 특정사이트 사용권한, 정보빌리기 / 로그인할 떄에 많이 쓰이는 개념이다. 사용권한이나 정보를 빌리는 과정에서의 규칙 같은 것인데, 입장권 개념이 아니고 유저가 A사이트에 입장하면 사용권한이 있다고 하자 , 그 사용권한을 B사이트를 운영하는 누군가가 유저대신 A사이트의 권한을 빌릴 수 있다. 동의 절차가 지나면 A사이트는 유저 정보들을 제공한다.. 이것을 잘 이용하면 A사이트의 회원정보를 B사이트에서 사용할 수 있는 것.. 회원가입시 사용하는 것 --> 우리가 잘아는 소셜로그인(네이버,카카오,구글 등)

Next.js는 NextAuth.js 와 Auth.js 가 있어서 라이브러리 설치하고 코드 복붙하면 끝임. 소셜로그인, 아이디/비번 로그인 전부 구현 가능합니다. JWT, session 방식 구현도 가능합니다. DB adapter 기능을 이용하면 DB에 session을 저장해두고 유저 관리도 가능합니다.

단점은 id/pw 방식 사용시 tokken 방식(JWT)만 써야됨. 이는 개발자가 직접 id/pw 취급하면 보안이슈가 있어서 ... 어쩌고 session 금지당했음.

### 1024

OAuth로 소셜로그인 만들기! : 아이디/비번관리 필요없음. 그럼 단순하게 생각해보자.. 깃헙한테 로그인해서 허락을 받아야하겠지요? 깃헙 setting - OAuth 들어가서 app하나 만들어보자.. (URL만 안겹치게 다른 app하고..)

1. 깃헙에서 비밀번호까지 세팅하고, npm i next-auth를 해준다.
2. pages/api/auth 폴더생성. [...nextauth].js 파일생성

로그인 버튼은 useclient로 따로 작성해주고, signIn() 함수를 끌어다 쓰면 기능 끝이다.
로그인하고나면, 로그인 유저정보 출력을 위해선 서버컴포넌트, 서버기능 안에서 getServerSession()을 통해 볼 수 있다. 대충 변수에 담아서 찎어보면 name,email,image등이 나오네요. 알아서 활용하면 됩니다.

### 1026

기본적으로 next-auth는 JWT 방식으로 동작을함.(토근) 로그인하면 JWT입장권을 만들어서 유저한테 보내주고, JWT까보고 별이상 없으면 입장시켜줌. 로그인 구현은 쉽지만, 이 방식이 싫다면,
DB adapter을 켜놓으면 session을 사용해서 유저를 관리하는데, 첫로그인시 자동회원가입. DB에 보관한다. 그래서 로그인된 유저정보가 필요하면 DB에서 조회해본다.. `npm install @next-auth/mongodb-adapter` 안되면 npm unistall mongodb -> npm i mongodb@4 하고 다시 설치.
다됐으면 [...nextauth].js 의 providers에 adpter: MongoDBAdapter(connectDB), 항복을 import하고 추가해준다.

다른 DB쓰려면 다른 db adapter 세팅해주면됨. 예를들어 redis는 데이터 저장을 하드가 아니라 램에 저장해주기 때문에 session 방식을 구현할때 즐겨쓴다고 한다.

아무튼 어댑터 설정하고 로그인을 하면, db를 확인해보자. accounts, sessiopns, users등.. 첨보는 컬렉션이 추가되어있을것이다.(아마도 test라는 곳에 생김)

1. sessions: 현재 로그인된 유저 세션정보 저장용. 유저 한명이 로그인 할때마다 해당 컬렉션에 도큐먼트가 하나씩 발행된다. 세션토큰, 아이디, expires도 있다 임의로 수정 삭제도 가능하다.
2. users: 가입된 유저들 정보.
3. accounts: 유저의 계정정보가 들어가있음. 2번과 3번은 하나의 유저가 여러가지 계정을 가지고 있을 수 있기 때문.. github+google 등.. users도큐먼트에는 한사람의 정보만 있고, accounts는 다수의 계정을 가지고 있을 경우 여러개가 생긴다. email이 같으면 같은 유저로 간주함..

다른 database에 유저정보 저장하려면. database.js 안의 url. ...mongodb.net/?...을 ...mongodb.net/forum?... 처럼 지정해주면 된다.

그렇다면 본인이 쓴 글만 수정/삭제하려면? 삭제기능을 업그레이드하면됨.
기존: 누가 삭제 api 요청하면 '그냥' 삭제새버림 => 업그레이드: 요청자 == 글쓴이 일치하면 삭제해주는 식으로 수정.. 그러기 위해선 **글을 작성할때마다 어떤유저가 작성하는지.. 이메일이나 id등을 함께 글작성 기능에 넣어주자.**

이런식이면 될거같은데요?
post/new.js

```let session = await getServerSession(요청, 응답, authOptions);
  if (session) {
    요청.body.author = session.user.email;
  }
```
