db를 써볼건데, 표처럼 데이터를 보관하는 관계형 db(sql계열), 비관계형 db(몽고, 클라우드 파이어스토어 등)가 있다. 몽고db는 obj처럼 데이터를 저장할 수 있다. sql문법이 필요없기 때문에 몽고db는 진입장벽이 낮다. 분산처리도 잘해준다.

관계형 데이터베이스는 데이터를 엑셀처럼 표에 저장합니다.
데이터 입출력시 SQL이라는 언어를 사용해야하고 미리 스키마 정의(표만들기)도 해야하고 데이터 중복저장을 피하기 위해 정규화해야하고 여러가지 귀찮은 점들을 신경써야합니다.
주로 안정적인 데이터저장과 운영이 필요한 곳에서 쓰면 좋습니다.

비관계형 데이터베이스는 자료를 조금 더 자유로운 형식으로 저장할 수 있고
SQL 언어, 스키마 정의(표 만들기), 정규화 이런게 대부분 필요없습니다.
분산처리를 기본적으로 잘해서 주로 SNS 서비스처럼 많은 데이터 입출력이 필요할 때도 강점을 보입니다. 데이터를 자바스크립트 object자료형과 똑같은 모양으로 저장할 수 있어서 편리합니다.

MongoDB의 데이터 저장 방식
collection을 하나 만들어서 그 안에 document 를 만들어서 데이터를 기록하는 식으로 데이터들을 저장합니다.
비유하자면 collection은 폴더, document는 파일이라고 생각합시다.
Nodejs 강의에선 collection이 폴더, document가 데이터 한 줄이라고 한거같은데 그렇게 생각해도 됩니다.

{ 데이터이름1 : 값1, 데이터이름2 : 값2 ... }
document에 데이터를 기록할 때는 자바스크립트 object 자료형과 똑같이 저장하면 됩니다.

object 자료형은 이렇게 데이터를 저장하는데 이거 그대로 사용하면 됩니다.

### 0903

database에 데이터를 add해보자. 몽고db에 들어가서 데이터를 추가하면 database name은 하나의 프로젝트(사이트 하나당 하나가 일반적이나, 때에 따라 여러개의 db를 생성하기도 함), collection name은 하나의 '폴더'라고 생각하면 된다. collection 폴더 안에 여러개의 document(메모장 파일. 여기에 객체 자료들을 저장함)를 또 하위저장하는 구조가 됨.
insert document를 누르면 키와 값을 입력하는 공간이 있고, 제일 상단에는 기본적으로 부여되는 doc \_id번호가 있다.

// DB를 불러왔으면 페이지는 이제 어떻게 꾸미는가?
모든 개발자들 다 똑같다. 먼저 구현하고 싶은 기능을 '한글'로 풀어써봐라. 그 다음엔 그것에 맞게

1. HTML페이지를 만들어 놓음(뼈대)
2. 그 페이지 방문하면 DB에서 글 꺼내옴
3. 글들을 HTML에 꽂아넣음

// 기본적으로 next에서 라우팅 하는 방법은 다들 아실걸요. 근데 1000개도 넘는 페이지 만들겁니까? 그럴때에는 dynamic route 쓰면 됩니다. 비슷한 페이지는 여러개 만들 필요가 없습니다.

1. 우선 폴더를 [작명] 작명합니다.
2. 그러면 예를들어, detail/~ 뒤에 아무거나 입력해서 접속해도 하위 page.js를 보여줄것임.
3. 근데 진짜 '아무거나'라고 해서 똑같은 내용만 보여주면 안되니까. 범위를 지정해주려면, 여타 다른 블로그의 라우팅 방식처럼, 게시글의 id값(유저가 URL에 입력할 값)을 detail/???에 들어오게 하면 되지요. 방법은 detail/??? 이하에 올 컴포넌트 안에서 props를 출력해보면 params에 대한 정보가 나온다!

### 0908

1. 상세페이지 만드는 것처럼 url과 여러페이지 만들려면 [Dynamic Route] 사용
2. 현재 URL이 뭔지 궁금하면 props/useRouter
3. 페이지 이동, prefetch 등은 useRouter

- usePathname() 쓰면 현재 URL 출력해주고
  useSearchParams() 쓰면 search parameter (query string) 출력해주고
  useParams() 쓰면 [dynamic route]에 입력한내용 (URL 파라미터) 을 출력해줍니다.

### 0910

+글 작성 기능을 넣어보자!
순서대로,

1. 글 작성 페이지 필요하겠쬬?
2. 버튼 누르면 DB에 저장하는 방식? no!! 유저가 글에 공백이나 기타 이상한 것을 담아 보낼 수 있기 때문에 db에 '바로' 저장하는건 위험한 행동이다. 중간에 서버를 하나를 둬서 글 검사하도록 합니다.(이런 방식을 무슨 3-tier architecture 모라모라 한답니다.)
3. 서버라는건 뭐 해달라고하면 요청하면 해주는 프로그램. 서버 프로그램은 어떻게 짜는데요 그럼?
   그 형식은 /URL + method(GET,POST,PUT,DELETE,PATCH 등)로 짜면 된다. method는 정확한 기능들이 나누어져 있습니다.

-next에서 서버 기능을 개발하는건 두가지 방식이 있음.
첫번재는 루트경로에 pages/api/..js 파일을 만드는것,
다른 하나는 app/api/..js 를 만드는건데 후자가 더 최신에 나온것이긴 하다만 강의날을 기준으로 아직 나사빠진 기능이 더 많아서 page/api/~로 진행

-next는 자동 라우팅 기능이 있기 때문에 서버기능을 위해 pages/api와 같이 파일과 폴더를 만들어 놓으면 어떤 사람이 /apit/test로 CRUD와 관련된 요청을하면 '파일안의 코드'를 실행시켜줌!

### 0919

글 수정 페이지를 만들어보자. 근데 기능 정의하는데 어려움을 겪는다구요? 그럼 네이버 블로그 같은 곳을 참고해보십시오. 수정페이지를 들어가보면 큰 특징이 있슴.

1. 글 작성페이지와 'UI'가 같다. (사실 절대 조건은 아니지만 ux를 고려할때 똑같이 설계하는게 맞다)
2. 기존에 작성했던 내용이 채워져있다(아마 DB에 있는 내용)

결론은

1. list에서 글 수정 버튼 하나씩 달아줍시다.
2. 수정페이지를 만듭시다.(글도 db에서 가져오기)
3. 수정페이지에서 글 발행 누르면 db에 있던 내용을 수정하도록 합시다.

### 0926

Nextjs 에선 server / client component 들을 보여줘야할 때 최대한 서버에서 미리 html을 만들어서 보내려고 하기 때문에 server - client로 감싸진 형태로 제작한뒤, DB에서 가져온 데이터를 server 컴포넌트에서 작성한뒤, props로 client로 전송해주는 방식으로 만들자. (seo를 고려할때에)

fetch 코드가 길고 귀찮아서 편리하게 바꿔주는 axios같은 라이브러리 설치해서 쓰는 사람들이 많습니다. 근데 Nextjs 13부터는 fetch가 특별한 기능이 추가되어있기 때문에
server component 함수 안에서 fetch() 쓸 일이 있을 경우 그거 그대로 쓰는게 좋습니다.
지금의 client component 에선 라이브러리 설치하든 뭐하든 편한거 아무거나 대충 써도 됩니다.

### 1004

애니메이션 어떻게 줌?
css에서 애니메 동작 전, 후 스타일만 생각하고 작성하면된다.

-지금까지 서버에 데이터를 보내는 방법으로,
-fetch에서 body에 담는법, -<form>태그에서 <input>에 넣어 보내는법을 알아봤다.

### 1022

중요\*\* 기능구현 다 했다면 언제나 그 다음에 할 일은 성능향상입니다.
2개의 rendering 방법과 캐싱기능에 대해 알아봅시다.

우선 Next.js로 만든 서버를 어디 배포하려면 터미널 열어서 npm run build를 먼저 해야합니다.
이상한 리액트 문법으로 작성한 코드들을 브라우저 친화적인 html, js, css 파일로 바꿔주는 작업입니다.
그 다음에 npm run start 해두면 실제로 유저 요청을 처리할 수 있는 Next.js 서버가 완성됩니다.(개발 서버 아니고 실제 서버 띄워줌.)
물론 실제 운영할 사이트면 AWS같은 클라우드에 올려서 npm run start 해놓으면 되는데 그건 나중에 해봅시다.

run build를 하고나면 라우팅 된 페이지들을 보여주는데(이름과 사이즈 등을 알려줌), O는 static rendering(default) 해주겠다라는 의미이다.(npm run build 할 때 만든 html페이지 그대로 유저에게 보여줌). 람다(들입자)는 dynamic rendering 해주겠다는 의미이다. next에서 단순하게 page를 만들면 단순하게 static rendering 해준다.

static rendering 단순한 기능. 미리페이지 완성본 만들어놨기 때문에 전송 빠름.
dynamic rendering 유저가 페이지에 접속할떄마다 html 새로 만들어서 보내줌. npm run build 할때 만든건 버리고 새로 만들어줌.두개 방식의 구분은 자동으로 됨. fetch, useSearchParams(), cookies(), headers() [dynamic route] 페이지에서 사용시 자동으로 dynamic rendering 해줌.

근데 간혹가다가 이상하게 작업된 페이지들이 있음. (예를 들어 DB에서 게시글 가져와하는 list는 static으로 되어있음. 매번 html을 새로 해줘야하는데도..) 그렇기 때문에 npm run build 과정이 중요하다. 단적인 예로 개발 서버 말고 npm run start 한 서버에서 글을 작성해보면 static rendering이 된 html을 가지고 있기 때문에 list에 새로운 글이 반영되지 않는다. 그롷다면 list 페이지를 dynamic rendering으로 만들어보자.

list 페이지에서 export const dynamic = "force-dynamic"; 하면 dynamic, static으로 하면 static으로 전환해줌. 작성한 다음엔 꼭\* npm run build 과정을 거쳐주길 바람.

하지만 dynamic rendering도 항상 html을 다시 그려야하기 때문에 유저가 많으면 서버나 DB무리가 갈 수도 있기 때문에 그럴때에는 '캐싱' 해줄 수 있따. 데이터를(완성본) 잠깐 몰래 저장해두고, 재사용 하는 것이다. 예를 들어 GET 요청 결과 같은 것을 잠깐 저장해두고 재사용이 가능하다.
